<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> THM x86 Assembly Crash Course | NonoHM </title> <meta name="author" content="NonoHM "> <meta name="description" content="Welcome to my personnal website. I am currently a 2nd year student in the " but r et t program. i like doing sports and music besides learning new things in it.> <meta name="keywords" content="jekyll, jekyll-theme, portfolio-website, writeups, projects"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://nonohm.github.io/blog/2024/THM-x86-Assembly-Crash-Course/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> NonoHM </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">THM x86 Assembly Crash Course</h1> <p class="post-meta"> April 14, 2024 • NonoHM </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/thm"> <i class="fa-solid fa-hashtag fa-sm"></i> THM</a>   <a href="/blog/tag/malware-analysis"> <i class="fa-solid fa-hashtag fa-sm"></i> Malware Analysis</a>   <a href="/blog/tag/x86-assembly"> <i class="fa-solid fa-hashtag fa-sm"></i> x86 Assembly</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="task-1---introduction">Task 1 - Introduction</h2> <p>The assembly language is the lowest level of human-readable language and is also the highest level of language into which a binary can be reliably decompiled. That is why knowing the basics of the assembly language is essential when doing reverse engineering because malware samples are most likely to be compiled binaries. The two options are decompiling or disassembling but the problem with disasembling is that a lot of information in the source code is removed, thus natural names for variables or functions are changed in the compiling process. That is why the most reliable code we have is assembly code.</p> <h3 id="learning-objectives">Learning Objectives</h3> <p>We will be covering the following topics:</p> <ul> <li>Opcodes and operands</li> <li>General assembly instructions</li> <li>Arithmetic and logical instructions</li> <li>Conditionals</li> <li>Branching instructions</li> </ul> <h2 id="task-2---opcodes-and-operands">Task 2 - Opcodes and Operands</h2> <p>The code of a program to be executed by the CPU needs to be written ion its binary form, so it is a sequence of 1s and 0s. To be understandable for humans, the instructions are gathered into groups of 8 bits to form a byte and one byte form 2 hex digits. Among these, there are opcodes and operands; opcodes represent the actual operations and operands represent the registers, memory locations or immediate values on which the operations are performed.</p> <h3 id="opcodes">Opcodes</h3> <p>Like said before, Opcodes are numbers that correspond to instructions performed by the CPU. A disassembler reads opcodes and translates them into human readable text.</p> <p>An example of instruction that moves the number <code class="language-plaintext highlighter-rouge">0x5f</code> (95 in decimal form) into <em>eax</em> register:</p> <pre><code class="language-asm">040000:    b8 5f 00 00 00    mov eax, 0x5f
</code></pre> <ul> <li> <code class="language-plaintext highlighter-rouge">040000</code>: Address where the instruction is located</li> <li> <code class="language-plaintext highlighter-rouge">b8</code>: Opcode <code class="language-plaintext highlighter-rouge">mov eax</code> </li> <li> <code class="language-plaintext highlighter-rouge">5f 00 00 00</code>: Operand <code class="language-plaintext highlighter-rouge">0x5f</code> </li> </ul> <blockquote> <p>Note In little-endian, the instruction would be written <code class="language-plaintext highlighter-rouge">b8 00 00 00 5f</code>.</p> </blockquote> <h3 id="types-of-operands">Types of Operands</h3> <p>In general, there are three types of operands in ASM:</p> <ul> <li> <strong>Immediate Operands</strong>: Fixed values like <code class="language-plaintext highlighter-rouge">0x5f</code>.</li> <li> <strong>Registers</strong>: Registers are operands like <code class="language-plaintext highlighter-rouge">eax</code> </li> <li> <strong>Memory Operands</strong>: They are denoted by square brackets and reference memory locations. <code class="language-plaintext highlighter-rouge">[eax]</code> signifies the value present in <code class="language-plaintext highlighter-rouge">eax</code>.</li> </ul> <h3 id="questions">Questions</h3> <p><strong>What are the hex codes that denote the assembly operations called?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">Opcodes</code></em></p> <p><strong>Which type of operand is denoted by square brackets?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">Memory Operands</code></em></p> <h2 id="task-3---general-instructions">Task 3 - General Instructions</h2> <p>Instructions tell the CPU what operation to perform and operands are used to store results into register or memory.</p> <p><strong><code class="language-plaintext highlighter-rouge">mov</code> instruction</strong></p> <p>The mov instruction moves a value from one location to another. The syntax is:</p> <pre><code class="language-asm">mov destination, source
</code></pre> <p>The mov instruction can move a fixed value to a register, a register to another register, or a value in a memory location to a register.</p> <ul> <li> <strong>Fixed value to register</strong>: <code class="language-plaintext highlighter-rouge">mov eax, 0x5f</code> </li> <li> <strong>Value stored in register to register</strong>: <code class="language-plaintext highlighter-rouge">mov eax, ebx</code> </li> <li> <strong>Value stored in memory location to register</strong>: <code class="language-plaintext highlighter-rouge">mov eax, [0x5fccbe]</code> or <code class="language-plaintext highlighter-rouge">mov eax, [ebx]</code> or <code class="language-plaintext highlighter-rouge">mov eax, [ebx+4]</code> </li> </ul> <p><em>Value stored in memory location to register explained</em></p> <p>The first example takes the value stored in <code class="language-plaintext highlighter-rouge">0x5fccbe</code> to <code class="language-plaintext highlighter-rouge">eax</code>. The second example takes the value stored into the memory address, contanied into <code class="language-plaintext highlighter-rouge">ebx</code> to eax. Example:</p> <pre><code class="language-asm">mov ebx, 0x5fccbe
mov eax, [ebx]
; = mov eax, [0x5fccbe]
</code></pre> <p>The third example does the same thing with an offset of 4 in the memory location like <code class="language-plaintext highlighter-rouge">[0x5fccbe+4]</code>.</p> <p><strong><code class="language-plaintext highlighter-rouge">lea</code> instruction</strong></p> <p>The lea instruction stands for <em>load effective address</em>. While the mov instruction moves the data from the source to the detsination, the lea instruction moves the memory address of the source to the destination. The syntax is:</p> <pre><code class="language-asm">lea destination, source
</code></pre> <p>Here, <code class="language-plaintext highlighter-rouge">lea eax, [ebp+4]</code> moves the memory address located into <code class="language-plaintext highlighter-rouge">ebp</code> and adds 4.</p> <p><strong><code class="language-plaintext highlighter-rouge">nop</code> instruction</strong></p> <p>nop stands for no operation because it moves eax value into itself, resulting in no meaningful opreation. The nop instructions are used for consuming CPU cycles while waiting for an operation or other such purposes. The syntax is:</p> <pre><code class="language-asm">nop
</code></pre> <p><strong>Shift instructions</strong></p> <p>Shift instructions serve to shift each bit to left or right by adding a certain number of 0s at the start or at the end. The syntax is:</p> <pre><code class="language-asm">shr destination, count
shl destination, count
</code></pre> <p>This means overflowing is possible like:</p> <pre><code class="language-asm">mov eax, 0x00000101
shr eax, 1
; eax =&gt; 0x00000010 and CR Flag is set to 1
</code></pre> <p><strong>Rotate instructions</strong></p> <p>Rotate instructions are similar to the shift ones; the bits are shifted to the left or right but the end bit of the value returns back to the start if the shift goes to the right and the first bit returns back to the end if the shift goes to the left. The syntax is:</p> <pre><code class="language-asm">ror destination, count
rol destination, count
</code></pre> <p>Examples:</p> <pre><code class="language-asm">; Right shift
mov eax, 0b00000101 ; or 0x05
ror eax, 1
; eax =&gt; 0b10000010 or 0x82

; Left shift
mov ebx, 10100000 , or 0xa0
rol ebx, 1
; ebx =&gt; 01000001 or 0x41
</code></pre> <h3 id="questions-1">Questions</h3> <p><strong>In mov eax, ebx, which register is the destination operand?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">eax</code></em></p> <p><strong>What instruction performs no action?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">nop</code></em></p> <h2 id="task-4---flags">Task 4 - Flags</h2> <p>In x86 assembly language, CPU has several flags that indicate the outcome of certain operations or conditions which are stored in EFLAGS/RFLAGS register.</p> <table> <thead> <tr> <th style="text-align: center">Flag</th> <th style="text-align: center">Abbreviation</th> <th style="text-align: center">Explanation</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">Carry</td> <td style="text-align: center">CF</td> <td style="text-align: center">Set when a carry-out or borrow is required from the most significant bit in an arithmetic operation. Also used for bit-wise shifting operations.</td> </tr> <tr> <td style="text-align: center">Parity</td> <td style="text-align: center">PF</td> <td style="text-align: center">Set if the least significant byte of the result contains an even number of 1 bits.</td> </tr> <tr> <td style="text-align: center">Auxiliary</td> <td style="text-align: center">AF</td> <td style="text-align: center">Set if a carry-out or borrow is required from bit 3 to bit 4 in an arithmetic operation (BCD arithmetic).</td> </tr> <tr> <td style="text-align: center">Zero</td> <td style="text-align: center">ZF</td> <td style="text-align: center">Set if the result of the operation is zero.</td> </tr> <tr> <td style="text-align: center">Sign</td> <td style="text-align: center">SF</td> <td style="text-align: center">Set if the result of the operation is negative (i.e., the most significant bit is 1).</td> </tr> <tr> <td style="text-align: center">Overflow</td> <td style="text-align: center">OF</td> <td style="text-align: center">Set if there’s a signed arithmetic overflow (e.g., adding two positive numbers and getting a negative result or vice versa).</td> </tr> <tr> <td style="text-align: center">Direction</td> <td style="text-align: center">DF</td> <td style="text-align: center">Determines the direction for string processing instructions. If DF=0, the string is processed forward; if DF=1, the string is processed backward.</td> </tr> <tr> <td style="text-align: center">Interrupt Enable</td> <td style="text-align: center">IF</td> <td style="text-align: center">If set (1), it enables maskable hardware interrupts. If cleared (0), interrupts are disabled.</td> </tr> </tbody> </table> <p>Flags can be used in conditional jumps and are crucial for implementing conditional branching in assembly code.</p> <h3 id="questions-2">Questions</h3> <p><strong>Which flag will be set if the result of the operation is zero? (Answer in abbreviation)</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">ZF</code></em></p> <p><strong>Which flag will be set if the result of the operation is negative? (Answer in abbreviation)</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">SF</code></em></p> <h2 id="task-5---arithmetic-and-logical-instructions">Task 5 - Arithmetic and Logical Instructions</h2> <h3 id="arithmetic-instructions">Arithmetic Instructions</h3> <p><strong>Addition and Subtraction Instructions</strong></p> <p>In the addition instruction, the value is added to the destination and then stored into it. The syntax is:</p> <pre><code class="language-asm">add destination, value
; x = x + value
</code></pre> <p>In the substraction instruction, the destination is substracted by the value and then stored into the destination. The syntax is:</p> <pre><code class="language-asm">sub destination, value
; x = x - value
</code></pre> <p>The value can be a constant or a register. For substraction, ZF is set if the result is zero and CF is set if the destination is smaller than the value.</p> <p><strong>Multiplication and Division Instructions</strong></p> <p>The multiplication and division operations use the eax and edx registers.</p> <p>The multiply instruction has the following syntax:</p> <pre><code class="language-asm">mul value
</code></pre> <p>It multiplies the value with the one stored into <code class="language-plaintext highlighter-rouge">eax </code>and stores the result into <code class="language-plaintext highlighter-rouge">edx:eax</code>, beceause the multiplication of two 32-bit values can often result in higher ones. The lower bits are in <code class="language-plaintext highlighter-rouge">eax</code> and the higher bits are in <code class="language-plaintext highlighter-rouge">edx</code>.</p> <p>Tha value can be another register or a constant.</p> <p>The division instruction has the following syntax:</p> <pre><code class="language-asm">div value
</code></pre> <p>It divides the 64-bit value in <code class="language-plaintext highlighter-rouge">edx:eax</code> and saves the result in <code class="language-plaintext highlighter-rouge">eax</code> and the reminder in <code class="language-plaintext highlighter-rouge">edx</code>.</p> <p><strong>Increment and Decrement Instructions</strong></p> <p>These instructions increment or decrement the operand by 1. The syntax is:</p> <pre><code class="language-asm">inc eax ; Increase by 1
dec eax ; Decrease by 1
</code></pre> <h3 id="logical-instructions">Logical Instructions</h3> <p><strong>AND instruction</strong></p> <p>The AND intruction performs a bitwise (bit per bit) AND operation on the operands.</p> <table> <thead> <tr> <th>A</th> <th>B</th> <th>A AND B</th> </tr> </thead> <tbody> <tr> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <td>0</td> <td>1</td> <td>0</td> </tr> <tr> <td>1</td> <td>0</td> <td>0</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> </tr> </tbody> </table> <p>The syntax is:</p> <pre><code class="language-asm">and destination, source
; mv ax, 0x0000
; and ax, 0xFFFF
; =&gt; ax = 0x0000
</code></pre> <p><strong>OR instruction</strong></p> <p>The OR intruction performs a bitwise (bit per bit) OR operation on the operands.</p> <table> <thead> <tr> <th>A</th> <th>B</th> <th>A OR B</th> </tr> </thead> <tbody> <tr> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <td>1</td> <td>0</td> <td>1</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> </tr> </tbody> </table> <p>The syntax is:</p> <pre><code class="language-asm">or destination, source
; mv ax, 0x0000
; or ax, 0xFFFF
; =&gt; ax = 0xFFFF
</code></pre> <p><strong>NOT Instruction</strong></p> <p>The NOT instruction takes one operand and simply inverts the operand bits.</p> <table> <thead> <tr> <th>A</th> <th>NOT A</th> </tr> </thead> <tbody> <tr> <td>0</td> <td>1</td> </tr> <tr> <td>1</td> <td>0</td> </tr> </tbody> </table> <p>The syntax is:</p> <pre><code class="language-asm">not operand
</code></pre> <p><strong>XOR Instruction</strong></p> <p>The XOR intruction performs a bitwise (bit per bit) XOR operation on the operands.</p> <table> <thead> <tr> <th>A</th> <th>B</th> <th>A XOR B</th> </tr> </thead> <tbody> <tr> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <td>1</td> <td>0</td> <td>1</td> </tr> <tr> <td>1</td> <td>1</td> <td>0</td> </tr> </tbody> </table> <p>The syntax is:</p> <pre><code class="language-asm">xor destination, source
; mv ax, 0x0000
; or ax, 0xFFFF
; =&gt; ax = 0xFFFF
</code></pre> <h3 id="questions-3">Questions</h3> <p><strong>In a subtraction operation, which flag is set if the destination is smaller than the subtracted value?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">Carry Flag</code></em></p> <p><strong>Which instruction is used to increase the value of a register</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">inc</code></em></p> <p><strong>Do the following instructions have the same result? (yea/nay)</strong></p> <pre><code class="language-asm">xor eax, eax
mov eax, 0
</code></pre> <p><em>Answer: <code class="language-plaintext highlighter-rouge">yea</code></em></p> <h2 id="task-6---conditionals-and-branching">Task 6 - Conditionals and branching</h2> <h3 id="conditionals">Conditionals</h3> <p>Conditional instructions determine if two values are equal to, greater than or less than each other.</p> <p><strong>TEST Instruction</strong></p> <p>The test instruction performs a bitwise AND operation and instead of storing the result in the destination, it sets the Zero Flag if the result is O. This is often used to check if an operand is a null value. The syntax is:</p> <p><code class="language-plaintext highlighter-rouge">test destination, source</code></p> <p><strong>CMP Instruction</strong></p> <p>The CMP instruction compares two operands and sets the ZF or CF depending of the result. It works by performing a substration, then set the ZF if both operands are equal or CF if the source &gt; destination. CF and ZF are clear if destination &gt; source. The syntax is:</p> <pre><code class="language-asm">cmp destination, source
</code></pre> <h3 id="branching">Branching</h3> <p>Branching changes the value of the Instruction Pointer in order to change program’s flow.</p> <p><strong>JMP Instruction</strong></p> <p>The JMP instruction makes the IP jump to a specified location. The syntax is:</p> <pre><code class="language-asm">jmp location ;Memory Address
</code></pre> <p><strong>Conditional Jumps</strong></p> <p>Conditional jumps decide to jump based on the Flag Registers values.</p> <table> <thead> <tr> <th>Instruction</th> <th>Explanation</th> </tr> </thead> <tbody> <tr> <td>jz</td> <td>Jump if the ZF is set (ZF=1).</td> </tr> <tr> <td>jnz</td> <td>Jump if the ZF is not set (ZF=0).</td> </tr> <tr> <td>je</td> <td>Jump if equal. Often used after a CMP instruction.</td> </tr> <tr> <td>jne</td> <td>Jump if not equal. Often used after a CMP instruction.</td> </tr> <tr> <td>jg</td> <td>Jump if the destination is greater than the source operand. Performs signed comparison and is often used after a CMP instruction.</td> </tr> <tr> <td>jl</td> <td>Jump if the destination is lesser than the source operand. Performs signed comparison and is often used after a CMP instruction.</td> </tr> <tr> <td>jge</td> <td>Jump if greater than or equal to. Jumps if the destination operand is greater than or equal to the source operand. Similar to the above instructions.</td> </tr> <tr> <td>jle</td> <td>Jump if lesser than or equal to. Jumps if the destination operand is lesser than or equal to the source operand. Similar to the above instructions.</td> </tr> <tr> <td>ja</td> <td>Jump if above. Similar to jg, but performs an unsigned comparison.</td> </tr> <tr> <td>jb</td> <td>Jump if below. Similar to jl, but performs an unsigned comparison.</td> </tr> <tr> <td>jae</td> <td>Jump if above or equal to. Similar to the above instructions.</td> </tr> <tr> <td>jbe</td> <td>Jump if below or equal to. Similar to the above instructions.</td> </tr> </tbody> </table> <h3 id="questions-4">Questions</h3> <p><strong>Which flag is set as a result of the test instruction being zero?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">Zero Flag</code></em></p> <p><strong>Which of the below operations uses subtraction to test two values? 1 or 2?</strong></p> <ol> <li>cmp eax, ebx</li> <li>test eax, ebx</li> </ol> <p><em>Answer: <code class="language-plaintext highlighter-rouge">1</code></em></p> <p><strong>Which flag is used to identify whether a jump will be taken or not after a jz or jnz instruction?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">Zero Flag</code></em></p> <h2 id="task-7---stack-and-function-calls">Task 7 - Stack and Function calls</h2> <h3 id="the-stack">The Stack</h3> <p>We have already learnt that the stack is a LIFO (Last In, First Out) Memory. This means the last variable pushed onto the stack is the first to pop.</p> <p><strong>PUSH Instruction</strong></p> <p>The push instruction push the source operand onto the stack, becoming the top of the stack. The value of the memory location is pointed by the Stack Pointer (ESP). The syntax is:</p> <pre><code class="language-asm">push source
</code></pre> <ul> <li> <code class="language-plaintext highlighter-rouge">pusha</code>: Pushes all 16-bit GP registers to the stack from AX to DI.</li> <li> <code class="language-plaintext highlighter-rouge">pushad</code>: Pushes all 32-bit GP registers to the stack from EAX to EDI.</li> </ul> <p><strong>POP Instruction</strong></p> <p>The pop instruction retrieves the value from the top of the stack and stores it in the destination operand. As a result, the ESP is also decremented, updated to point to the new top of the stack. The syntax is:</p> <pre><code class="language-asm">pop destination
</code></pre> <ul> <li> <code class="language-plaintext highlighter-rouge">popa</code>: Pops all 16-bit GP registers from the stack from DI to AX.</li> <li> <code class="language-plaintext highlighter-rouge">popad</code>: Pops all 32-bit GP registers from the stack from EDI to EAX.</li> </ul> <p><strong>CALL Instruction</strong></p> <p>The <code class="language-plaintext highlighter-rouge">call</code> instruction is used to perform a function call. It saves the return address which is the one just after the <code class="language-plaintext highlighter-rouge">call</code> instruction by pushing it onto the stack, then it jumps to the specified address and begins executing from here. The syntax is:</p> <p><code class="language-plaintext highlighter-rouge">call location</code></p> <h3 id="questions-5">Questions</h3> <p><strong>Which instruction is used for performing a function call?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">call</code></em></p> <p><strong>Which instruction is used to push all registers to the stack?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">pusha</code></em></p> <h2 id="task-8---practice-time">Task 8 - Practice Time</h2> <p>Run instructions and observe the stack, memory and register on the Assembly Emulator.</p> <h3 id="questions-6">Questions</h3> <p><strong>While running the MOV instructions, what is the value of [eax] after running the 4th instruction? (in hex)</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">0x00000040</code></em></p> <p><strong>What error is displayed after running the 6th instruction from the MOV instruction section?</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">Memory to memory data movement is not allowed.</code></em></p> <p><strong>Run the instructions from the stack section. What is the value of eax after the 9th instruction? (in hex)</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">0x00000025</code></em></p> <p><strong>Run the instructions from the stack section. What is the value of edx after the 12th instruction? (in hex)</strong></p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">0x00000010</code></em></p> <p>Run the instructions from the stack section. After POP ecx, what is the value left at the top of the stack? (in hex)</p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">0x00000010</code></em></p> <p>Run the cmp and test instructions. Which flags are triggered after the 3rd instruction? (Note: Use these abbreviations in alphabetical order with no spaces: CF,PF,SF,ZF)</p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">PF,ZF</code></em></p> <p>Run the test and the cmp instructions. Which flags are triggered after the 11th instruction? (Note: Use these abbreviations in alphabetical order with no spaces: CF,PF,SF,ZF)</p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">CF,SF</code></em></p> <p>Run the instructions from the lea section. What is the value of eax after running the 9th instruction? (in hex)</p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">0x0000004B</code></em></p> <p>Run the instructions from the lea section. What is the final value found in the ECX register? (in hex)</p> <p><em>Answer: <code class="language-plaintext highlighter-rouge">0x00000045</code></em></p> <h2 id="task-9---conclusion">Task 9 - Conclusion</h2> <p>In this module, we’ve explored foundational concepts of x86 assembly language, focusing on essential instructions and operations. We learned how to convert opcodes into assembly language, and covered general instructions like move (mov), load effective address (lea), shift, and rotate. Additionally, we delved into arithmetic operations including addition, subtraction, multiplication, and division. We also discussed conditionals for branching, understanding how to control program flow based on conditions. Lastly, we explored stack operations (push and pop) and how they are used in function calls.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/THM-x86-Architecture-Overview/">THM x86 Architecture Overview</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/THM-Introduction-to-Cryptography/">THM Introduction to Cryptography</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/THM-Windows-Internals/">THM Windows Internals</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/THM-Identity-and-Access-Management/">THM Identity and Access Management</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/THM-Security-Principles/">THM Security Principles</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 NonoHM . Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?da39b660470d1ba6e6b8bf5f37070b6e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>